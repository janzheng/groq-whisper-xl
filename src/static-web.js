// Embedded static files for the web interface
// This file is auto-generated by scripts/build-static.js - do not edit manually!

export const STATIC_FILES = {
  '/': `<!DOCTYPE html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Groq Whisper XL - Audio Transcription</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://code.iconify.design/iconify-icon/1.0.7/iconify-icon.js"></script>
    <script>
      tailwind.config = {
        theme: {
          extend: {
            colors: {
              'terminal-bg': '#1a1a1a',
              'terminal-bg-light': '#2d2d2d',
              'terminal-text': '#ffffff',
              'terminal-text-dim': '#b0b0b0',
              'terminal-accent': '#d1d5db',
              'terminal-border': '#444444',
              'status-success': '#00ff00',
              'status-error': '#ff4444',
              'status-warning': '#ffaa00',
              'status-info': '#44aaff',
            }
          }
        }
      }
    </script>
    <style>
      body {
        font-family: 'Courier New', 'Monaco', 'Menlo', monospace;
      }
      
      ::-webkit-scrollbar {
        width: 8px;
      }
      
      ::-webkit-scrollbar-track {
        background: #1a1a1a;
      }
      
      ::-webkit-scrollbar-thumb {
        background: #444444;
        border-radius: 4px;
      }
      
      ::-webkit-scrollbar-thumb:hover {
        background: #666666;
      }
      
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.5; }
      }
      
      .animate-pulse-slow {
        animation: pulse 2s infinite;
      }
      
      @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
      }
      
      .animate-fade-in {
        animation: fadeIn 0.3s ease-in;
      }
      
      @keyframes spin {
        from { transform: rotate(0deg); }
        to { transform: rotate(360deg); }
      }
      
      .animate-spin {
        animation: spin 1s linear infinite;
      }
    </style>
    <script type="module" src="/assets/app.js"></script>
  </head>
  <body class="bg-terminal-bg text-terminal-text overflow-x-hidden">
    <div id="app"></div>
  </body>
</html> `,
  
  '/assets/app.js': `// Minimal Svelte-like implementation for the web interface
const API_BASE = '';

// ============================================================================
// UNIFIED LOGGING SYSTEM (BROWSER VERSION)
// ============================================================================

/**
 * Browser-compatible version of the unified logging system
 * Maintains consistency with CLI and API logging
 */
class UnifiedLogger {
  static levels = {
    DEBUG: 0,
    INFO: 1,
    WARN: 2,
    ERROR: 3
  };

  static emojis = {
    start: '🚀', processing: '🔄', complete: '✅', failed: '❌',
    upload: '📤', download: '📥', file: '📁', delete: '🗑️',
    audio: '🎵', transcribe: '🎤', chunk: '🧩', stream: '🌊', llm: '🧠',
    api: '📡', webhook: '🔗', url: '🌐',
    info: 'ℹ️', warning: '⚠️', error: '❌', debug: '🔍', 
    stats: '📊', time: '⏱️', progress: '📈'
  };

  constructor(context = 'WEB', level = UnifiedLogger.levels.INFO) {
    this.context = context;
    this.level = level;
  }

  _formatMessage(emoji, message, data = null) {
    const timestamp = new Date().toLocaleTimeString();
    const prefix = \`\${emoji} [\${this.context}]\`;
    
    if (data && Object.keys(data).length > 0) {
      return \`\${prefix} \${message}\`;
    }
    return \`\${prefix} \${message}\`;
  }

  debug(message, data = null) {
    if (this.level <= UnifiedLogger.levels.DEBUG) {
      const formatted = this._formatMessage(UnifiedLogger.emojis.debug, message, data);
      console.log(formatted, data);
    }
  }

  info(emoji, message, data = null) {
    if (this.level <= UnifiedLogger.levels.INFO) {
      const emojiSymbol = UnifiedLogger.emojis[emoji] || emoji;
      const formatted = this._formatMessage(emojiSymbol, message, data);
      console.log(formatted, data);
    }
  }

  warn(message, data = null) {
    if (this.level <= UnifiedLogger.levels.WARN) {
      const formatted = this._formatMessage(UnifiedLogger.emojis.warning, message, data);
      console.warn(formatted, data);
    }
  }

  error(message, error = null, data = null) {
    if (this.level <= UnifiedLogger.levels.ERROR) {
      const formatted = this._formatMessage(UnifiedLogger.emojis.error, message, data);
      console.error(formatted, error, data);
    }
  }

  // Convenience methods for common operations
  upload(message, data = null) { this.info('upload', message, data); }
  download(message, data = null) { this.info('download', message, data); }
  processing(message, data = null) { this.info('processing', message, data); }
  complete(message, data = null) { this.info('complete', message, data); }
  chunk(message, data = null) { this.info('chunk', message, data); }
  transcribe(message, data = null) { this.info('transcribe', message, data); }
  llm(message, data = null) { this.info('llm', message, data); }
  api(message, data = null) { this.info('api', message, data); }
  stats(message, data = null) { this.info('stats', message, data); }
  stream(message, data = null) { this.info('stream', message, data); }
}

// Create web logger instances
const webLogger = new UnifiedLogger('WEB', UnifiedLogger.levels.INFO);
const streamLogger = new UnifiedLogger('STREAM', UnifiedLogger.levels.INFO);

// Component state
let jobs = [];
let isUploading = false;
let isStreaming = false;
let streamingTranscript = '';
let streamingProgress = 0;
let currentStreamingFilename = '';

// Initialize the app
function init() {
  loadStreamingJobsFromStorage();
  createApp();
  fetchJobs();
  // Remove auto-refresh interval - we'll use manual refresh button instead
}

// Save and load streaming jobs from localStorage
function saveStreamingJobsToStorage() {
  const streamingJobs = jobs.filter(job => job.processing_method === 'streaming');
  localStorage.setItem('groq_streaming_jobs', JSON.stringify(streamingJobs));
  webLogger.debug('Saved streaming jobs to localStorage', { count: streamingJobs.length });
}

function loadStreamingJobsFromStorage() {
  try {
    const stored = localStorage.getItem('groq_streaming_jobs');
    if (stored) {
      const streamingJobs = JSON.parse(stored);
      jobs = [...streamingJobs];
      webLogger.info('stream', 'Loaded streaming jobs from localStorage', { count: streamingJobs.length });
    }
  } catch (error) {
    webLogger.warn('Failed to load streaming jobs from localStorage', error);
  }
}

function createApp() {
  const app = document.getElementById('app');
  app.innerHTML = \`
    <main class="max-w-6xl mx-auto p-5">
      <!-- CLI Header -->
      <div class="border border-terminal-border bg-terminal-bg-light p-4 mb-4">
        <div class="flex items-center gap-2 text-lg font-bold">
          <iconify-icon icon="mdi:lightning-bolt" class="text-terminal-accent"></iconify-icon>
          <span class="text-terminal-accent">Groq Whisper XL</span>
        </div>
        <div class="text-terminal-text-dim mt-2">
          Fast, accurate audio transcription powered by Groq's Whisper API with intelligent chunking and LLM enhancement.
        </div>
        
        <div class="mt-3">
          <div class="space-y-1 text-sm">
            <div class="flex items-center gap-2 text-terminal-text-dim">
              <iconify-icon icon="mdi:file-music" class="text-xs"></iconify-icon>
              <span>Universal file support up to 1GB with smart processing</span>
            </div>
            <div class="flex items-center gap-2 text-terminal-text-dim">
              <iconify-icon icon="mdi:brain" class="text-xs"></iconify-icon>
              <span>AI-powered error correction for improved accuracy</span>
            </div>
            <div class="flex items-center gap-2 text-terminal-text-dim">
              <iconify-icon icon="mdi:play-speed" class="text-xs"></iconify-icon>
              <span>Real-time streaming transcription with live results</span>
            </div>
          </div>
        </div>
      </div>
      
      <!-- Upload Section -->
      <div class="border border-terminal-border bg-terminal-bg-light p-4 mb-4">
        <div class="font-bold text-center mb-4 border-b border-terminal-border pb-2">Main Menu</div>
        
        <div class="grid grid-cols-1 lg:grid-cols-2 gap-4">
          <!-- Direct Upload Section -->
          <div class="border border-terminal-border p-4 flex flex-col">
            <div class="flex items-center gap-2 mb-4 font-bold text-terminal-accent">
              <iconify-icon icon="mdi:rocket-launch" class="text-lg"></iconify-icon>
              <span>Direct Upload & Processing</span>
            </div>
            <div class="text-xs text-terminal-text-dim mb-4">
              Upload your file and get notified when processing is complete. Files are processed in the background - check "Running Jobs" for progress.
            </div>
            
            <!-- Source Selection -->
            <div class="mb-4">
              <div class="font-bold mb-2">Source:</div>
              <div class="flex gap-2 mb-3">
                <button id="direct-file-btn" class="bg-gray-700 border border-terminal-border text-terminal-text px-4 py-2 hover:bg-gray-700 transition-colors flex-1 flex items-center justify-center gap-2">
                  <iconify-icon icon="mdi:file-outline"></iconify-icon> File
                </button>
                <button id="direct-url-btn" class="bg-terminal-bg border border-terminal-border text-terminal-text px-4 py-2 hover:bg-gray-700 transition-colors flex-1 flex items-center justify-center gap-2">
                  <iconify-icon icon="mdi:web"></iconify-icon> URL
                </button>
              </div>
              
              <!-- File Upload Area -->
              <div id="direct-file-section">
                <div id="upload-area" class="border-2 border-dashed border-terminal-border p-6 text-center cursor-pointer transition-all hover:border-terminal-accent hover:bg-gray-900/20">
                  <iconify-icon icon="mdi:file-plus" class="text-3xl text-terminal-text-dim mb-2"></iconify-icon>
                  <div class="font-bold">Drop files here or click to browse</div>
                  <div class="text-xs text-terminal-text-dim">MP3, WAV, M4A, FLAC, etc. (up to 1GB)</div>
                </div>
                <input type="file" id="file-input" accept="audio/*,video/*" class="hidden">
              </div>
              
              <!-- URL input (hidden by default) -->
              <div id="direct-url-section" class="hidden">
                <input id="url-input" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-3 py-2 w-full focus:outline-none focus:border-terminal-accent" type="url" placeholder="https://example.com/audio.mp3">
              </div>
            </div>
            
            <!-- Settings -->
            <div class="mb-4 flex-1">
              <div class="font-bold mb-2">Settings:</div>
              <div class="space-y-3">
                <div>
                  <label class="flex items-center gap-2 cursor-pointer">
                    <input type="checkbox" id="use-llm" class="w-4 h-4">
                    <iconify-icon icon="mdi:brain" class="text-terminal-accent"></iconify-icon>
                    <span class="text-terminal-accent">LLM Error Correction</span>
                    <span class="text-terminal-text-dim">(Improves accuracy)</span>
                  </label>
                </div>
                
                <div>
                  <label class="text-terminal-text-dim block mb-1">Webhook URL (optional):</label>
                  <input id="webhook-url" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-3 py-2 w-full focus:outline-none focus:border-terminal-accent" type="url" placeholder="https://your-webhook.com/endpoint">
                </div>
              </div>
            </div>
            
            <button id="direct-process-btn" class="bg-terminal-accent text-terminal-bg px-4 py-2 hover:bg-gray-300 transition-colors w-full font-bold flex items-center justify-center gap-2">
              <iconify-icon icon="mdi:microphone"></iconify-icon> Transcribe Audio
            </button>
          </div>
          
          <!-- Streaming Upload Section -->
          <div class="border border-terminal-border p-4 flex flex-col">
            <div class="flex items-center gap-2 mb-4 font-bold text-terminal-accent">
              <iconify-icon icon="mdi:waveform" class="text-lg"></iconify-icon>
              <span>Streaming Transcription</span>
            </div>
            <div class="text-xs text-terminal-text-dim mb-4">
              Real-time processing with live transcript streaming. See results as they're generated - perfect for demos and testing.
            </div>
            
            <!-- Source Selection -->
            <div class="mb-4">
              <div class="font-bold mb-2">Source:</div>
              <div class="flex gap-2 mb-3">
                <button id="stream-file-btn" class="bg-gray-700 border border-terminal-border text-terminal-text px-4 py-2 hover:bg-gray-700 transition-colors flex-1 flex items-center justify-center gap-2">
                  <iconify-icon icon="mdi:file-outline"></iconify-icon> File
                </button>
                <button id="stream-url-btn" class="bg-terminal-bg border border-terminal-border text-terminal-text px-4 py-2 hover:bg-gray-700 transition-colors flex-1 flex items-center justify-center gap-2">
                  <iconify-icon icon="mdi:web"></iconify-icon> URL
                </button>
              </div>
              
              <!-- Stream File Upload Area -->
              <div id="stream-file-section">
                <div id="stream-upload-area" class="border-2 border-dashed border-terminal-border p-6 text-center cursor-pointer transition-all hover:border-terminal-accent hover:bg-gray-900/20">
                  <iconify-icon icon="mdi:file-plus" class="text-3xl text-terminal-text-dim mb-2"></iconify-icon>
                  <div class="font-bold">Drop files here or click to browse</div>
                  <div class="text-xs text-terminal-text-dim">MP3, WAV, M4A, FLAC, etc. (up to 1GB)</div>
                </div>
                <input type="file" id="stream-file-input" accept="audio/*,video/*" class="hidden">
              </div>
              
              <!-- Stream URL input (hidden by default) -->
              <div id="stream-url-section" class="hidden">
                <input id="stream-url-input" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-3 py-2 w-full focus:outline-none focus:border-terminal-accent" type="url" placeholder="https://example.com/audio.mp3">
              </div>
            </div>
            
            <!-- Settings -->
            <div class="mb-4 flex-1">
              <div class="font-bold mb-2">Settings:</div>
              <div class="space-y-3">
                <div>
                  <label class="text-terminal-text-dim block mb-1">Chunk size:</label>
                  <select id="chunk-size" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-3 py-2 w-full focus:outline-none focus:border-terminal-accent">
                    <option value="0.25" selected>0.25MB (Ultra-fast)</option>
                    <option value="0.5">0.5MB (Fast)</option>
                    <option value="1">1MB (Balanced)</option>
                    <option value="2">2MB (Fewer API calls)</option>
                  </select>
                </div>
                
                <div>
                  <label class="text-terminal-text-dim block mb-1">LLM correction:</label>
                  <select id="llm-mode" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-3 py-2 w-full focus:outline-none focus:border-terminal-accent">
                    <option value="disabled" selected>Disabled (fastest)</option>
                    <option value="per_chunk">Per-chunk (real-time)</option>
                    <option value="post_process">Post-process (better quality)</option>
                  </select>
                </div>
              </div>
            </div>
            
            <button id="start-stream-btn" class="bg-status-info text-terminal-bg px-4 py-2 hover:bg-blue-600 transition-colors w-full font-bold flex items-center justify-center gap-2">
              <iconify-icon icon="mdi:waveform"></iconify-icon> Select File to Transcribe
            </button>
          </div>
        </div>

      </div>
      
      <!-- Streaming Display Section -->
      <div id="streaming-display" class="border border-terminal-border bg-terminal-bg-light p-4 mb-4 hidden">
        <div class="font-bold text-center mb-4 border-b border-terminal-border pb-2 flex items-center justify-center gap-2">
          <iconify-icon icon="mdi:waveform" class="text-lg"></iconify-icon> Live Streaming Transcription
        </div>
        
        <!-- Streaming Status -->
        <div id="streaming-status" class="mb-4">
          <div class="flex items-center gap-2 mb-2">
            <span class="w-2 h-2 bg-status-info rounded-full animate-pulse-slow"></span>
            <span class="font-bold text-status-info">Streaming in progress...</span>
            <span id="streaming-filename" class="text-terminal-text-dim"></span>
          </div>
          
          <!-- Progress bar -->
          <div class="bg-terminal-bg border border-terminal-border h-5 overflow-hidden">
            <div id="streaming-progress-bar" class="bg-status-info h-full flex items-center justify-center text-terminal-bg text-xs font-bold transition-all duration-300" style="width: 0%;">0%</div>
          </div>
          
          <div id="streaming-info" class="text-xs text-terminal-text-dim mt-2 grid grid-cols-2 md:grid-cols-4 gap-2">
            <span>Chunks: <span id="chunks-processed">0</span>/<span id="total-chunks">?</span></span>
            <span>Size: <span id="file-size">-</span></span>
            <span>Elapsed: <span id="elapsed-time">0s</span></span>
            <span>Mode: <span id="stream-mode">-</span></span>
          </div>
        </div>
        
        <!-- Live Transcript -->
                  <div class="border border-terminal-border bg-terminal-bg">
            <div class="p-3 border-b border-terminal-border font-bold text-terminal-accent flex items-center gap-2">
              <iconify-icon icon="mdi:text-box" class="text-lg"></iconify-icon> Live Transcript:
            </div>
          <div id="streaming-transcript" class="p-4 max-h-80 overflow-y-auto font-mono text-sm leading-relaxed">
            <div class="text-terminal-text-dim italic">Waiting for transcription results...</div>
          </div>
        </div>
        
        <!-- Stop button -->
        <div id="stop-stream-section" class="mt-4 text-center">
          <button id="stop-stream-btn" class="bg-status-error text-terminal-bg px-6 py-2 hover:bg-red-600 transition-colors font-bold flex items-center gap-2">
            <iconify-icon icon="mdi:stop"></iconify-icon> Stop Streaming
          </button>
        </div>
      </div>
      
      <!-- Jobs Section -->
      <div>
        <div id="running-jobs" class="mb-6"></div>
        
        <div>
          <div class="flex items-center justify-between py-2 border-b border-terminal-border">
            <div class="flex items-center gap-2">
              <iconify-icon icon="mdi:check-circle" class="text-status-success"></iconify-icon>
              <span class="font-bold text-status-success">Completed Jobs (<span id="completed-count">0</span>)</span>
            </div>
            <button id="refresh-jobs-btn" onclick="window.refreshJobs()" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-3 py-1 text-xs hover:bg-gray-700 transition-colors flex items-center gap-1">
              <iconify-icon icon="mdi:refresh" class="text-sm"></iconify-icon> Refresh
            </button>
          </div>
          
          <div id="completed-jobs"></div>
        </div>
      </div>
      
      <!-- Footer -->
      <div class="border border-terminal-border mt-4 p-3 bg-terminal-bg-light text-center">
        <div class="text-xs text-terminal-text-dim">
          Groq Whisper XL - Universal Audio Transcription Tool
        </div>
      </div>
    </main>
  \`;
  
  setupEventListeners();
}

function setupEventListeners() {
  // File upload area (drag & drop)
  const uploadArea = document.getElementById('upload-area');
  const fileInput = document.getElementById('file-input');
  
  uploadArea.addEventListener('click', () => fileInput.click());
  uploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    uploadArea.classList.add('border-terminal-accent', 'bg-green-900/20');
    uploadArea.classList.remove('border-terminal-border');
  });
  uploadArea.addEventListener('dragleave', () => {
    uploadArea.classList.remove('border-terminal-accent', 'bg-green-900/20');
    uploadArea.classList.add('border-terminal-border');
  });
  uploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    uploadArea.classList.remove('border-terminal-accent', 'bg-green-900/20');
    uploadArea.classList.add('border-terminal-border');
    
    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      // Store selected file but don't upload yet
      fileInput.files = e.dataTransfer.files;
      updateUploadAreaWithFile(files[0]);
    }
  });
  
  fileInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    if (files.length > 0) {
      updateUploadAreaWithFile(files[0]);
    }
  });
  
  // Direct upload source selection
  document.getElementById('direct-file-btn').addEventListener('click', () => {
    document.getElementById('direct-file-section').classList.remove('hidden');
    document.getElementById('direct-url-section').classList.add('hidden');
    document.getElementById('direct-file-btn').classList.add('bg-gray-700');
    document.getElementById('direct-url-btn').classList.remove('bg-gray-700');
  });
  
  document.getElementById('direct-url-btn').addEventListener('click', () => {
    document.getElementById('direct-file-section').classList.add('hidden');
    document.getElementById('direct-url-section').classList.remove('hidden');
    document.getElementById('direct-url-btn').classList.add('bg-gray-700');
    document.getElementById('direct-file-btn').classList.remove('bg-gray-700');
    document.getElementById('url-input').focus();
  });
  
  // Unified direct process button
  document.getElementById('direct-process-btn').addEventListener('click', () => {
    const fileSection = document.getElementById('direct-file-section');
    const urlSection = document.getElementById('direct-url-section');
    
    if (!fileSection.classList.contains('hidden')) {
      // File mode
      const files = Array.from(fileInput.files);
      if (files.length > 0) {
        uploadFile(files[0]);
      } else {
        // No file selected, trigger file picker
        fileInput.click();
      }
    } else if (!urlSection.classList.contains('hidden')) {
      // URL mode
      uploadFromUrl();
    }
  });
  
  // Stream upload area (drag & drop)
  const streamUploadArea = document.getElementById('stream-upload-area');
  const streamFileInput = document.getElementById('stream-file-input');
  
  streamUploadArea.addEventListener('click', () => streamFileInput.click());
  streamUploadArea.addEventListener('dragover', (e) => {
    e.preventDefault();
    streamUploadArea.classList.add('border-terminal-accent', 'bg-green-900/20');
    streamUploadArea.classList.remove('border-terminal-border');
  });
  streamUploadArea.addEventListener('dragleave', () => {
    streamUploadArea.classList.remove('border-terminal-accent', 'bg-green-900/20');
    streamUploadArea.classList.add('border-terminal-border');
  });
  streamUploadArea.addEventListener('drop', (e) => {
    e.preventDefault();
    streamUploadArea.classList.remove('border-terminal-accent', 'bg-green-900/20');
    streamUploadArea.classList.add('border-terminal-border');
    
    const files = Array.from(e.dataTransfer.files);
    if (files.length > 0) {
      // Store selected file but don't stream yet
      streamFileInput.files = e.dataTransfer.files;
      updateStreamUploadAreaWithFile(files[0]);
    }
  });
  
  streamFileInput.addEventListener('change', (e) => {
    const files = Array.from(e.target.files);
    if (files.length > 0) {
      updateStreamUploadAreaWithFile(files[0]);
    }
  });
  
  // Streaming source selection
  document.getElementById('stream-file-btn').addEventListener('click', () => {
    document.getElementById('stream-file-section').classList.remove('hidden');
    document.getElementById('stream-url-section').classList.add('hidden');
    document.getElementById('stream-file-btn').classList.add('bg-gray-700');
    document.getElementById('stream-url-btn').classList.remove('bg-gray-700');
    
    // Reset start button based on file selection
    const streamBtn = document.getElementById('start-stream-btn');
    if (streamFileInput.files.length > 0) {
      streamBtn.innerHTML = '<iconify-icon icon="mdi:waveform"></iconify-icon> Live Transcribe ' + streamFileInput.files[0].name;
    } else {
      streamBtn.innerHTML = '<iconify-icon icon="mdi:waveform"></iconify-icon> Select File to Transcribe';
    }
  });
  
  document.getElementById('stream-url-btn').addEventListener('click', () => {
    document.getElementById('stream-file-section').classList.add('hidden');
    document.getElementById('stream-url-section').classList.remove('hidden');
    document.getElementById('stream-url-btn').classList.add('bg-gray-700');
    document.getElementById('stream-file-btn').classList.remove('bg-gray-700');
    document.getElementById('stream-url-input').focus();
    
    // Reset start button
    const streamBtn = document.getElementById('start-stream-btn');
    streamBtn.innerHTML = '<iconify-icon icon="mdi:waveform"></iconify-icon> Live Transcribe URL';
  });
  

  
  document.getElementById('start-stream-btn').addEventListener('click', () => {
    const urlSection = document.getElementById('stream-url-section');
    const fileInput = document.getElementById('stream-file-input');
    
    if (!urlSection.classList.contains('hidden')) {
      // URL mode
      const urlInput = document.getElementById('stream-url-input');
      if (urlInput.value.trim()) {
        startUrlStreaming(urlInput.value.trim());
      } else {
        alert('Please enter an audio URL first');
      }
    } else {
      // File mode
      const files = Array.from(fileInput.files);
      if (files.length > 0) {
        startFileStreaming(files[0]);
      } else {
        // No file selected, trigger file picker
        fileInput.click();
      }
    }
  });
  
  document.getElementById('stop-stream-btn').addEventListener('click', stopStreaming);
}

function updateUploadAreaWithFile(file) {
  const uploadArea = document.getElementById('upload-area');
  uploadArea.innerHTML = 
    '<iconify-icon icon="mdi:file-music" class="text-3xl text-terminal-accent mb-2"></iconify-icon>' +
    '<div class="font-bold">' + file.name + '</div>' +
    '<div class="text-terminal-accent font-bold">Ready to transcribe (' + formatBytes(file.size) + ')</div>' +
    '<div class="text-xs text-terminal-text-dim">Click "Transcribe Audio" to start</div>';
}

function updateStreamUploadAreaWithFile(file) {
  const streamUploadArea = document.getElementById('stream-upload-area');
  streamUploadArea.innerHTML = 
    '<iconify-icon icon="mdi:file-music" class="text-3xl text-terminal-accent mb-2"></iconify-icon>' +
    '<div class="font-bold">' + file.name + '</div>' +
    '<div class="text-terminal-accent font-bold">Ready to transcribe (' + formatBytes(file.size) + ')</div>' +
    '<div class="text-xs text-terminal-text-dim">Click "Live Transcribe" to begin</div>';
    
  // Update start button
  const streamBtn = document.getElementById('start-stream-btn');
  streamBtn.innerHTML = '<iconify-icon icon="mdi:waveform"></iconify-icon> Live Transcribe ' + file.name;
}

// Streaming functionality
let streamController = null;
let streamStartTime = Date.now();
let currentAbortController = null;

async function startFileStreaming(file) {
  if (isStreaming) return;
  
  const chunkSize = parseFloat(document.getElementById('chunk-size').value);
  const llmMode = document.getElementById('llm-mode').value;
  
  // Update button to show processing state
  const startBtn = document.getElementById('start-stream-btn');
  startBtn.innerHTML = '<iconify-icon icon="mdi:rocket-launch"></iconify-icon> Transcribing ' + file.name + '...';
  startBtn.disabled = true;
  
  const formData = new FormData();
  formData.append('file', file);
  formData.append('chunk_size_mb', chunkSize.toString());
  
  if (llmMode !== 'disabled') {
    formData.append('use_llm', 'true');
    formData.append('llm_mode', llmMode);
  } else {
    formData.append('use_llm', 'false');
  }
  
  try {
    await startStreaming('/stream', {
      method: 'POST',
      body: formData
    }, file.name);
  } catch (error) {
    // Reset button on error
    startBtn.innerHTML = '<iconify-icon icon="mdi:waveform"></iconify-icon> Live Transcribe ' + file.name;
    startBtn.disabled = false;
    throw error;
  }
}

async function startUrlStreaming(url) {
  if (isStreaming) return;
  
  const chunkSize = parseFloat(document.getElementById('chunk-size').value);
  const llmMode = document.getElementById('llm-mode').value;
  
  // Update button to show processing state
  const startBtn = document.getElementById('start-stream-btn');
  const displayName = url.split('/').pop() || 'audio file';
  startBtn.innerHTML = '<iconify-icon icon="mdi:rocket-launch"></iconify-icon> Transcribing ' + displayName + '...';
  startBtn.disabled = true;
  
  const payload = {
    url: url,
    chunk_size_mb: chunkSize
  };
  
  if (llmMode !== 'disabled') {
    payload.use_llm = true;
    payload.llm_mode = llmMode;
  } else {
    payload.use_llm = false;
  }
  
  try {
    await startStreaming('/stream', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload)
    }, displayName);
  } catch (error) {
    // Reset button on error
    startBtn.innerHTML = '<iconify-icon icon="mdi:waveform"></iconify-icon> Live Transcribe URL';
    startBtn.disabled = false;
    throw error;
  }
}

async function startStreaming(endpoint, requestOptions, filename) {
  if (isStreaming) return;
  
  isStreaming = true;
  streamingTranscript = '';
  streamingProgress = 0;
  streamStartTime = Date.now();
  currentStreamingFilename = filename;
  
  // Create a preliminary streaming job (will be updated with real data)
  const preliminaryStreamingJob = {
    job_id: 'stream_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
    filename: filename,
    status: 'processing',
    file_size: 0, // Will be updated when we get status event
    processing_method: 'streaming',
    upload_method: 'streaming',
    created_at: new Date().toISOString(),
    use_llm: document.getElementById('llm-mode').value !== 'disabled',
    llm_mode: document.getElementById('llm-mode').value,
    chunk_size_mb: parseFloat(document.getElementById('chunk-size').value),
    progress: 0
  };
  
  // Add to jobs list immediately so it shows in "Running Jobs"
  jobs.unshift(preliminaryStreamingJob);
  saveStreamingJobsToStorage();
  updateJobsList();
  
  // Create abort controller for this stream
  currentAbortController = new AbortController();
  
  // Add abort signal to request options
  requestOptions.signal = currentAbortController.signal;
  
  // Show streaming display
  setTimeout(() => {
    document.getElementById('streaming-display').classList.remove('hidden');
    document.getElementById('streaming-filename').textContent = filename;
    document.getElementById('stream-mode').textContent = document.getElementById('llm-mode').value;
    
    // Show stop button
    document.getElementById('stop-stream-section').classList.remove('hidden');
    
    // Reset display
    document.getElementById('streaming-transcript').innerHTML = '<div class="text-terminal-text-dim italic">Starting transcription...</div>';
    document.getElementById('streaming-progress-bar').style.width = '0%';
    document.getElementById('streaming-progress-bar').textContent = '0%';
  }, 100);
  
  try {
    const response = await fetch(endpoint, requestOptions);
    
    if (!response.ok) {
      throw new Error('Streaming failed: ' + response.status);
    }
    
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = '';
    
    while (true) {
      const { done, value } = await reader.read();
      
      if (done) {
        streamLogger.complete('Stream reader reached end');
        break;
      }
      
              if (!isStreaming) {
          streamLogger.info('warning', 'Stream stopped by user');
          break;
        }
      
      const chunk = decoder.decode(value, { stream: true });
      buffer += chunk;
      
      const lines = buffer.split('\\n');
      buffer = lines.pop() || '';
      
      for (const line of lines) {
        if (line.startsWith('data: ')) {
          try {
            const data = JSON.parse(line.slice(6));
            handleStreamEvent(data);
          } catch (error) {
            streamLogger.warn('Failed to parse stream data', { error: error.message });
          }
        }
      }
    }
    
  } catch (error) {
          streamLogger.error('Streaming error', error);
    
    // Don't show error if it was just an abort (user clicked stop)
    if (error.name !== 'AbortError') {
      displayStreamError(error.message);
          } else {
        streamLogger.info('warning', 'Stream aborted by user');
      }
  } finally {
    // Only call stopStreaming if still streaming (not completed normally)
          if (isStreaming) {
        streamLogger.warn('Stream ended unexpectedly, cleaning up...');
        stopStreaming();
      }
  }
}

function handleStreamEvent(data) {
  const { type } = data;
  
  switch (type) {
    case 'status':
      document.getElementById('file-size').textContent = formatBytes(data.total_size);
      document.getElementById('total-chunks').textContent = data.estimated_chunks;
      updateStreamingTranscript('📋 Starting transcription of ' + data.filename + ' (' + formatBytes(data.total_size) + ')...\\n');
      
      // Update the current streaming job with the correct file size and real job_id
      const currentStreamingJob = jobs.find(job => 
        job.processing_method === 'streaming' && 
        job.filename === currentStreamingFilename &&
        job.status === 'processing'
      );
      if (currentStreamingJob) {
        // Update with real backend job_id (replace temporary stream_ id)
        if (data.job_id && currentStreamingJob.job_id.startsWith('stream_')) {
          currentStreamingJob.job_id = data.job_id;
          webLogger.info('api', 'Updated streaming job with real backend job_id', { 
            old_id: currentStreamingJob.job_id, 
            new_id: data.job_id 
          });
        }
        currentStreamingJob.file_size = data.total_size;
        currentStreamingJob.estimated_chunks = data.estimated_chunks;
        saveStreamingJobsToStorage();
        updateJobsList();
      }
      break;
      
    case 'chunk_info':
      document.getElementById('total-chunks').textContent = data.total_chunks;
      updateStreamingTranscript('🧩 Ready to process ' + data.total_chunks + ' chunks (' + data.chunk_size_mb + 'MB each)\\n\\n');
      break;
      
    case 'chunk_start':
      updateProgress(data.progress);
      updateStreamingTranscript('🔄 Chunk ' + (data.chunk_index + 1) + ' (' + data.progress + '%) - transcribing...\\n');
      
      // Update job progress
      const processingJob = jobs.find(job => 
        job.processing_method === 'streaming' && 
        job.filename === currentStreamingFilename &&
        job.status === 'processing'
      );
      if (processingJob) {
        processingJob.progress = data.progress;
        saveStreamingJobsToStorage();
        updateJobsList();
      }
      break;
      
    case 'delta':
      if (data.llm_applied) {
        updateStreamingTranscript('📝 Raw: "' + data.raw_text + '"\\n');
        updateStreamingTranscript('🧠 LLM: "' + data.corrected_text + '"\\n\\n');
      } else if (data.llm_error) {
        updateStreamingTranscript('📝 "' + data.raw_text + '"\\n');
        updateStreamingTranscript('⚠️  LLM failed: ' + data.llm_error + '\\n\\n');
      } else {
        const text = data.text || data.raw_text;
        updateStreamingTranscript('📝 "' + text + '"\\n\\n');
      }
      
      // Update chunks processed counter
      const chunksProcessed = parseInt(document.getElementById('chunks-processed').textContent) + 1;
      document.getElementById('chunks-processed').textContent = chunksProcessed;
      break;
      
    case 'chunk_done':
      updateProgress(data.progress);
      updateStreamingTranscript('✅ Chunk ' + (data.chunk_index + 1) + ' completed (' + data.progress + '%)\\n\\n');
      break;
      
    case 'chunk_error':
      updateStreamingTranscript('❌ Chunk ' + (data.chunk_index + 1) + ' error: ' + data.error + '\\n\\n');
      break;
      
    case 'llm_processing':
      const mode = data.mode === 'post_process' ? 'post-processing' : 'per-chunk';
      updateStreamingTranscript('🧠 ' + (data.message || ('Applying LLM corrections (' + mode + ')...')) + '\\n');
      break;
      
    case 'llm_done':
      const doneMode = data.mode === 'post_process' ? 'Post-processing' : 'Per-chunk';
      updateStreamingTranscript('✅ ' + doneMode + ' LLM correction completed\\n');
      if (data.mode === 'post_process') {
        updateStreamingTranscript('📝 Improved transcript:\\n"' + data.corrected_text + '"\\n\\n');
      }
      break;
      
    case 'llm_error':
      const errorMode = data.mode === 'post_process' ? 'Post-processing' : 'Per-chunk';
      updateStreamingTranscript('❌ ' + errorMode + ' LLM correction failed: ' + data.error + '\\n');
      if (data.fallback_text) {
        updateStreamingTranscript('📝 Using original transcript: "' + data.fallback_text + '"\\n\\n');
      }
      break;
      
          case 'done':
        streamLogger.complete('Received done event from server');
        updateProgress(100);
        updateStreamingTranscript('\\n🎉 Transcription completed!\\n');
        updateStreamingTranscript('📊 Total segments: ' + data.total_segments + '\\n\\n');
        
        if (data.llm_correction_applied && data.corrected_transcript) {
          updateStreamingTranscript('📝 Raw transcript:\\n"' + data.raw_transcript + '"\\n\\n');
          updateStreamingTranscript('🧠 LLM-corrected transcript:\\n"' + data.corrected_transcript + '"\\n\\n');
        } else {
          updateStreamingTranscript('📝 Final transcript:\\n"' + data.final_transcript + '"\\n\\n');
        }
        
        // Show save option and mark as completed
        updateStreamingTranscript('💾 Transcript completed! Results will remain visible.\\n');
        
        // Update the existing streaming job with completion data
        // First try to find by job_id (preferred), then fall back to filename matching
        const completingJob = jobs.find(job => 
          job.processing_method === 'streaming' && 
          (job.job_id === data.job_id || 
           (job.filename === currentStreamingFilename && job.status === 'processing'))
        );
        
        let finalJob;
        if (completingJob) {
          // Update existing job with completion data
          completingJob.status = 'done';
          completingJob.completed_at = new Date().toISOString();
          completingJob.final_transcript = data.final_transcript;
          completingJob.raw_transcript = data.raw_transcript;
          completingJob.corrected_transcript = data.corrected_transcript;
          completingJob.total_segments = data.total_segments;
          completingJob.progress = 100;
          completingJob.file_size = data.total_size || completingJob.file_size || 0;
          
          finalJob = completingJob;
          webLogger.complete('Updated streaming job with completion data', { 
            job_id: completingJob.job_id, 
            final_length: data.final_transcript?.length || 0 
          });
        } else {
          // Fallback: create new job if existing one not found
          const streamingJob = {
            job_id: 'stream_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9),
            filename: currentStreamingFilename,
            status: 'done',
            file_size: data.total_size || 0,
            processing_method: 'streaming',
            upload_method: 'streaming',
            created_at: new Date(streamStartTime).toISOString(),
            completed_at: new Date().toISOString(),
            use_llm: data.llm_correction_applied || false,
            final_transcript: data.final_transcript,
            raw_transcript: data.raw_transcript,
            corrected_transcript: data.corrected_transcript,
            total_segments: data.total_segments,
            llm_mode: data.llm_mode
          };
          
          jobs.unshift(streamingJob);
          finalJob = streamingJob;
          webLogger.warn('Created fallback streaming job - existing job not found');
        }
        
        // Backend already saves its own job, so we only save locally and update UI
        saveStreamingJobsToStorage();
        updateJobsList();
        
        // Update UI to show completion
        const statusDiv = document.getElementById('streaming-status');
        statusDiv.innerHTML = 
          '<div class="flex items-center gap-2 mb-2">' +
            '<span class="w-2 h-2 bg-status-success rounded-full"></span>' +
            '<span class="font-bold text-status-success">Transcription completed!</span>' +
            '<span class="text-terminal-text-dim">' + currentStreamingFilename + '</span>' +
          '</div>' +
          '<div class="bg-terminal-bg border border-terminal-border h-5 overflow-hidden">' +
            '<div class="bg-status-success h-full flex items-center justify-center text-terminal-bg text-xs font-bold w-full">100% Complete</div>' +
          '</div>';
          
        // Reset streaming state but keep display visible
        isStreaming = false;
        
        // Clean up abort controller
        currentAbortController = null;
        
        // Reset stream button
        const startBtn = document.getElementById('start-stream-btn');
        startBtn.textContent = '🌊 Live Transcribe';
        startBtn.disabled = false;
        
        // Hide stop button when completed
        document.getElementById('stop-stream-section').classList.add('hidden');
        
        // Reset form inputs (but keep display visible)
        document.getElementById('stream-file-input').value = '';
        document.getElementById('stream-url-input').value = '';
        document.getElementById('stream-url-section').classList.add('hidden');
        document.getElementById('stream-file-section').classList.remove('hidden');
        document.getElementById('stream-file-btn').classList.add('bg-gray-700');
        document.getElementById('stream-url-btn').classList.remove('bg-gray-700');
        
        // Reset upload area
        const streamUploadArea = document.getElementById('stream-upload-area');
        streamUploadArea.innerHTML = 
          '<div>📁</div>' +
          '<div class="font-bold">Drop files here or click to browse</div>' +
          '<div class="text-xs text-terminal-text-dim">MP3, WAV, M4A, FLAC, etc. (up to 1GB)</div>';
        
        streamLogger.complete('Streaming completed successfully');
        break;
      
    case 'error':
      displayStreamError(data.error);
      break;
  }
  
  // Update elapsed time
  const elapsed = Math.round((Date.now() - streamStartTime) / 1000);
  document.getElementById('elapsed-time').textContent = elapsed + 's';
}

function updateProgress(progress) {
  streamingProgress = progress;
  const progressBar = document.getElementById('streaming-progress-bar');
  progressBar.style.width = progress + '%';
  progressBar.textContent = progress + '%';
}

function updateStreamingTranscript(text) {
  streamingTranscript += text;
  const transcriptDiv = document.getElementById('streaming-transcript');
  transcriptDiv.innerHTML = streamingTranscript.replace(/\\n/g, '<br>');
  transcriptDiv.scrollTop = transcriptDiv.scrollHeight;
}

function displayStreamError(error) {
  updateStreamingTranscript('\\n❌ Stream error: ' + error + '\\n');
  setTimeout(() => stopStreaming(), 3000);
}

function stopStreaming() {
  // Don't show stop message if we weren't actually streaming
  const wasActuallyStreaming = isStreaming && currentStreamingFilename && streamingTranscript;
  
  isStreaming = false;
  
  // Abort the current request if it exists
  if (currentAbortController) {
    currentAbortController.abort();
    currentAbortController = null;
  }
  
  // Reset stream button immediately
  const startBtn = document.getElementById('start-stream-btn');
  startBtn.textContent = '🌊 Live Transcribe';
  startBtn.disabled = false;
  
  // Hide stop button
  document.getElementById('stop-stream-section').classList.add('hidden');
  
  // Show that streaming was stopped only if we were actually streaming
  if (wasActuallyStreaming) {
    updateStreamingTranscript('\\n🛑 Streaming stopped by user\\n');
    
    // Update status to show stopped
    const statusDiv = document.getElementById('streaming-status');
    statusDiv.innerHTML = 
      '<div class="flex items-center gap-2 mb-2">' +
        '<span class="w-2 h-2 bg-status-warning rounded-full"></span>' +
        '<span class="font-bold text-status-warning">Streaming stopped</span>' +
        '<span class="text-terminal-text-dim">' + currentStreamingFilename + '</span>' +
      '</div>' +
      '<div class="bg-terminal-bg border border-terminal-border h-5 overflow-hidden">' +
        '<div class="bg-status-warning h-full flex items-center justify-center text-terminal-bg text-xs font-bold" style="width: ' + streamingProgress + '%;">' + streamingProgress + '% (Stopped)</div>' +
      '</div>';
  }
  
  // Reset form inputs
  document.getElementById('stream-file-input').value = '';
  document.getElementById('stream-url-input').value = '';
  document.getElementById('stream-url-section').classList.add('hidden');
  
  // Reset upload area if file was selected
  const streamUploadArea = document.getElementById('stream-upload-area');
  streamUploadArea.innerHTML = 
    '<div>📁</div>' +
    '<div class="font-bold">Drop files here or click to browse</div>' +
    '<div class="text-xs text-terminal-text-dim">MP3, WAV, M4A, FLAC, etc. (up to 1GB)</div>';
    
  // Reset streaming variables to prevent interference with other operations
  currentStreamingFilename = '';
  streamingTranscript = '';
  streamingProgress = 0;
}

async function fetchJobs() {
  try {
    console.log('=== FETCH JOBS CALLED ===');
    console.log('Jobs before fetch:', jobs.length, jobs.map(j => ({ id: j.job_id.slice(0, 8) + '...', method: j.processing_method })));
    
    const response = await fetch(API_BASE + '/jobs');
    if (response.ok) {
      const data = await response.json();
      const serverJobs = data.jobs || [];
      
      console.log('Server returned jobs:', serverJobs.length, serverJobs.map(j => ({ id: j.job_id.slice(0, 8) + '...', method: j.processing_method || 'direct' })));
      
      // Preserve ALL existing jobs that aren't from server (streaming jobs and recently added jobs)
      const localJobs = jobs.filter(job => job.processing_method === 'streaming');
      
      // Create a comprehensive map of ALL existing job IDs to avoid duplicates
      const allExistingJobIds = new Set(jobs.map(job => job.job_id));
      
      // Filter out server jobs that already exist locally (includes streaming AND server jobs we already have)
      const newServerJobs = serverJobs.filter(job => !allExistingJobIds.has(job.job_id));
      
      console.log('Local streaming jobs to preserve:', localJobs.length);
      console.log('New server jobs to add:', newServerJobs.length, newServerJobs.map(j => ({ id: j.job_id.slice(0, 8) + '...', method: j.processing_method || 'direct' })));
      
      // Merge: Keep local streaming jobs + existing server jobs + only NEW server jobs
      const existingServerJobs = jobs.filter(job => job.processing_method !== 'streaming');
      jobs = [...localJobs, ...existingServerJobs, ...newServerJobs];
      
      // Remove any actual duplicates that might slip through (final safety net)
      const uniqueJobs = [];
      const seenIds = new Set();
      for (const job of jobs) {
        if (!seenIds.has(job.job_id)) {
          seenIds.add(job.job_id);
          uniqueJobs.push(job);
        }
      }
      jobs = uniqueJobs;
      
      updateJobsList();
      
      console.log('Jobs after fetch and deduplication:', jobs.length, jobs.map(j => ({ id: j.job_id.slice(0, 8) + '...', method: j.processing_method })));
      
      webLogger.info('api', 'Fetched jobs', { 
        server_jobs: serverJobs.length, 
        new_server_jobs: newServerJobs.length,
        local_streaming: localJobs.length,
        existing_server: existingServerJobs.length,
        total: jobs.length,
        duplicates_removed: jobs.length - uniqueJobs.length
      });
    }
  } catch (error) {
    console.error('Fetch jobs error:', error);
    webLogger.error('Failed to fetch jobs', error);
  }
}

// Save completed streaming job to server KV storage
async function saveStreamingJobToServer(jobData) {
  try {
    const response = await fetch(API_BASE + '/save-streaming-job', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(jobData)
    });

    if (response.ok) {
      webLogger.info('api', 'Saved streaming job to server', { job_id: jobData.job_id });
    } else {
      const error = await response.json();
      webLogger.warn('Failed to save streaming job to server', { 
        job_id: jobData.job_id, 
        error: error.error || 'Unknown error' 
      });
    }
  } catch (error) {
    webLogger.warn('Failed to save streaming job to server', { 
      job_id: jobData.job_id, 
      error: error.message 
    });
  }
}

// Manual refresh with visual feedback
async function refreshJobs() {
  const refreshBtn = document.getElementById('refresh-jobs-btn');
  const originalContent = refreshBtn.innerHTML;
  
  // Show loading state
  refreshBtn.innerHTML = '<iconify-icon icon="mdi:loading" class="text-sm animate-spin"></iconify-icon> Refreshing...';
  refreshBtn.disabled = true;
  
  try {
    await fetchJobs();
    
    // Show success state briefly
    refreshBtn.innerHTML = '<iconify-icon icon="mdi:check" class="text-sm"></iconify-icon> Updated!';
    setTimeout(() => {
      refreshBtn.innerHTML = originalContent;
      refreshBtn.disabled = false;
    }, 1500);
    
  } catch (error) {
    // Show error state briefly
    refreshBtn.innerHTML = '<iconify-icon icon="mdi:alert" class="text-sm"></iconify-icon> Error';
    setTimeout(() => {
      refreshBtn.innerHTML = originalContent;
      refreshBtn.disabled = false;
    }, 2000);
  }
}

function updateJobsList() {
  const runningJobs = jobs.filter(job => 
    job.status === 'processing' || 
    job.status === 'uploaded' || 
    job.status === 'awaiting_upload'
  );
  
  const completedJobs = jobs.filter(job => 
    job.status === 'done' || 
    job.status === 'failed'
  );
  
  // Debug logging
  console.log('Jobs update - Total:', jobs.length, 'Running:', runningJobs.length, 'Completed:', completedJobs.length);

  webLogger.stats('Jobs update', { 
    total: jobs.length, 
    running: runningJobs.length, 
    completed: completedJobs.length
  });
  
  // Update running jobs
  const runningContainer = document.getElementById('running-jobs');
  if (runningJobs.length > 0) {
    const runningJobsHtml = runningJobs.map(job => createJobItem(job)).join('');
    runningContainer.innerHTML = 
      '<div class="font-bold mb-2 text-status-warning flex items-center gap-2">' +
        '<iconify-icon icon="mdi:sync" class="text-lg"></iconify-icon> Running Jobs (' + runningJobs.length + ')' +
      '</div>' +
      '<div class="max-h-96 overflow-y-auto border border-terminal-border">' +
        runningJobsHtml +
      '</div>';
  } else {
    runningContainer.innerHTML = '';
  }
  // Update completed jobs count
  document.getElementById('completed-count').textContent = completedJobs.length;
  
  // Always show completed jobs (no toggle anymore)
  const completedContainer = document.getElementById('completed-jobs');
  if (completedJobs.length > 0) {
    const completedJobsHtml = completedJobs.map(job => createJobItem(job)).join('');
    completedContainer.innerHTML = 
      '<div class="border border-terminal-border">' +
        completedJobsHtml +
      '</div>';
  } else {
    completedContainer.innerHTML = 
      '<div class="py-10 px-5 text-center text-terminal-text-dim">' +
        'No completed jobs' +
      '</div>';
  }
}

function createJobItem(job) {
  const statusColors = {
    processing: 'bg-status-info text-terminal-bg',
    uploaded: 'bg-status-info text-terminal-bg',
    failed: 'bg-status-error text-terminal-bg'
  };
  const statusClass = statusColors[job.status] || 'bg-status-warning text-terminal-bg';
  
  const statusIcon = {
    processing: '<iconify-icon icon="mdi:sync" class="text-xs animate-spin"></iconify-icon>',
    uploaded: '<iconify-icon icon="mdi:upload" class="text-xs"></iconify-icon>',
    failed: '<iconify-icon icon="mdi:alert-circle" class="text-xs"></iconify-icon>'
  }[job.status] || '<iconify-icon icon="mdi:clock" class="text-xs"></iconify-icon>';
  
  const expandId = 'expand-' + job.job_id.replace(/[^a-zA-Z0-9]/g, '');
  
  return '<div class="border-b border-terminal-border">' +
    '<div class="p-3 pr-4 hover:bg-gray-800/50 transition-colors cursor-pointer" onclick="window.toggleJobExpand(&quot;' + expandId + '&quot;, &quot;' + job.job_id.replace(/"/g, '&quot;') + '&quot;)">' +
      '<div class="flex items-start gap-3">' +
        // Main job info
        '<div class="flex-1 min-w-0">' +
          '<div class="flex items-center gap-2 mb-1">' +
            '<iconify-icon icon="mdi:file-music" class="text-terminal-accent"></iconify-icon>' +
            '<span class="font-bold">' + (job.filename || 'Unknown') + '</span>' +
            (job.upload_method === 'url' ? '<span class="text-status-info text-xs bg-blue-900/30 px-1 rounded">URL</span>' : '') +
            (job.upload_method === 'streaming' ? '<span class="text-status-info text-xs bg-blue-900/30 px-1 rounded">🌊 Streamed</span>' : '') +
          '</div>' +
          '<div class="flex flex-wrap gap-3 text-xs text-terminal-text-dim">' +
            '<span><iconify-icon icon="mdi:identifier" class="text-xs"></iconify-icon> ' + job.job_id.slice(0, 8) + '...</span>' +
            '<span><iconify-icon icon="mdi:file-outline" class="text-xs"></iconify-icon> ' + formatBytes(job.file_size || 0) + '</span>' +
            '<span><iconify-icon icon="mdi:cog" class="text-xs"></iconify-icon> ' + (job.processing_method || 'direct') + '</span>' +
            (job.total_segments > 0 ? '<span><iconify-icon icon="mdi:format-list-numbered" class="text-xs"></iconify-icon> ' + job.total_segments + ' segments</span>' : '') +
          '</div>' +
        '</div>' +
        
        // Status and delete button
        '<div class="flex items-center gap-2 flex-shrink-0">' +
          // Only show status badge for non-completed jobs
          (job.status !== 'done' ? 
            '<div class="px-2 py-1 text-xs font-bold uppercase ' + statusClass + ' flex items-center gap-1">' +
              statusIcon + ' ' + job.status +
            '</div>' : '') +
          // Delete button
          '<button onclick="event.stopPropagation(); window.deleteJob(&quot;' + job.job_id.replace(/"/g, '&quot;') + '&quot;)" class="text-status-error hover:bg-status-error hover:text-terminal-bg transition-colors p-1 rounded" title="Delete job">' +
            '<iconify-icon icon="mdi:delete" class="text-lg"></iconify-icon>' +
          '</button>' +
        '</div>' +
      '</div>' +
      
      // Progress bar ONLY for processing jobs (not completed ones)
      (job.progress !== undefined && job.status === 'processing' ? 
        '<div class="bg-terminal-bg border border-terminal-border h-5 overflow-hidden mt-2">' +
          '<div class="bg-terminal-accent h-full flex items-center justify-center text-terminal-bg text-xs font-bold transition-all duration-300" style="width: ' + (job.progress || 0) + '%;">' + (job.progress || 0) + '%</div>' +
        '</div>' : '') +
      
      // Basic info row
      '<div class="mt-2 flex flex-wrap gap-3 text-xs text-terminal-text-dim">' +
        '<span><iconify-icon icon="mdi:clock-outline" class="text-xs"></iconify-icon> ' + new Date(job.created_at).toLocaleString() + '</span>' +
        (job.use_llm ? '<span class="text-terminal-accent"><iconify-icon icon="mdi:brain" class="text-xs"></iconify-icon> LLM Enhanced</span>' : '') +
        (job.error ? '<span class="text-status-error"><iconify-icon icon="mdi:alert-circle" class="text-xs"></iconify-icon> Error: ' + job.error + '</span>' : '') +
      '</div>' +
    '</div>' +
    
    // Expandable section - will show transcript view for completed jobs, details for others
    '<div id="' + expandId + '" class="max-h-0 overflow-hidden transition-all duration-300">' +
      // Content will be populated by toggleJobExpand function
    '</div>' +
  '</div>';
}

function formatBytes(bytes) {
  if (bytes === 0) return '0 Bytes';
  const k = 1024;
  const sizes = ['Bytes', 'KB', 'MB', 'GB'];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

async function uploadFile(file) {
  if (isUploading || isStreaming) return;
  
  isUploading = true;
  const uploadArea = document.getElementById('upload-area');
  const originalContent = uploadArea.innerHTML;
  uploadArea.innerHTML = '<div>🔄 Uploading ' + file.name + ' (' + formatBytes(file.size) + ')...</div>';
  try {
    const formData = new FormData();
    formData.append('file', file);
    formData.append('use_llm', document.getElementById('use-llm').checked.toString());
    
    const webhookUrl = document.getElementById('webhook-url').value;
    if (webhookUrl) {
      formData.append('webhook_url', webhookUrl);
    }
    
    const response = await fetch(API_BASE + '/upload', {
      method: 'POST',
      body: formData
    });
    
    if (response.ok) {
      const result = await response.json();
      // Add to jobs list immediately
      jobs.unshift({
        job_id: result.job_id,
        filename: result.filename,
        status: 'processing',
        file_size: result.file_size,
        processing_method: result.processing_method,
        upload_method: 'direct',
        use_llm: document.getElementById('use-llm').checked,
        created_at: new Date().toISOString()
      });
      updateJobsList();
      
      // Show success message briefly
      uploadArea.innerHTML = '<div class="text-status-success">✅ ' + file.name + ' uploaded successfully! Transcription started...</div>';
      setTimeout(() => {
        uploadArea.innerHTML = originalContent;
        // Reset form
        document.getElementById('file-input').value = '';
        // No need to auto-refresh - job is already in the list
      }, 3000);
    } else {
      const error = await response.json();
              uploadArea.innerHTML = '<div class="text-status-error">❌ Upload failed: ' + (error.error || 'Unknown error') + '</div>';
        setTimeout(() => {
          uploadArea.innerHTML = originalContent;
          document.getElementById('file-input').value = '';
        }, 3000);
    }
    
  } catch (error) {
    webLogger.error('Upload error', error);
          uploadArea.innerHTML = '<div class="text-status-error">❌ Upload failed: ' + error.message + '</div>';
      setTimeout(() => {
        uploadArea.innerHTML = originalContent;
        document.getElementById('file-input').value = '';
      }, 3000);
  }
  
  isUploading = false;
}

async function uploadFromUrl() {
  const urlInput = document.getElementById('url-input');
  const url = urlInput.value.trim();
  
  if (!url || isUploading || isStreaming) return;
  
  isUploading = true;
  const btn = document.getElementById('url-upload-btn');
  const originalText = btn.textContent;
  btn.textContent = 'Downloading...';
  btn.disabled = true;
  
  // Extract filename from URL for display
  const displayFilename = url.split('/').pop() || 'audio file';
  
  try {
    const response = await fetch(API_BASE + '/upload-url', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        url: url,
        use_llm: document.getElementById('use-llm').checked,
        webhook_url: document.getElementById('webhook-url').value || null
      })
    });
    
    if (response.ok) {
      const result = await response.json();
      // Add to jobs list immediately
      jobs.unshift({
        job_id: result.job_id,
        filename: result.filename,
        status: 'processing',
        file_size: result.file_size,
        processing_method: result.processing_method,
        upload_method: 'url',
        source_url: result.source_url,
        use_llm: document.getElementById('use-llm').checked,
        created_at: new Date().toISOString()
      });
      updateJobsList();
      
      // Show success feedback
      btn.textContent = '✅ Downloaded!';
      btn.classList.add('bg-status-success');
      setTimeout(() => {
        btn.textContent = originalText;
        btn.classList.remove('bg-status-success');
        btn.disabled = false;
        // No need to auto-refresh - job is already in the list
      }, 2000);
      
      // Reset form
      urlInput.value = '';
    } else {
      const error = await response.json();
      btn.textContent = '❌ Failed';
      btn.classList.add('bg-status-error');
      setTimeout(() => {
        btn.textContent = originalText;
        btn.classList.remove('bg-status-error');
        btn.disabled = false;
      }, 3000);
    }
    
  } catch (error) {
    webLogger.error('URL upload error', error);
    btn.textContent = '❌ Error';
    btn.classList.add('bg-status-error');
    setTimeout(() => {
      btn.textContent = originalText;
      btn.classList.remove('bg-status-error');
      btn.disabled = false;
    }, 3000);
  }
  
  isUploading = false;
}
async function deleteJob(jobId) {
  if (!confirm('Are you sure you want to delete this job?')) return;
  
  console.log('=== DELETE JOB CALLED ===');
  console.log('Job ID to delete:', jobId);
  console.log('Jobs before deletion:', jobs.length, jobs.map(j => ({ id: j.job_id, method: j.processing_method })));
  
  const job = jobs.find(j => j.job_id === jobId);
  console.log('Found job to delete:', job);
  
  if (!job) {
    console.error('Job not found for deletion:', jobId);
    alert('Job not found');
    return;
  }
  
  const initialJobCount = jobs.length;
  
  // Handle streaming jobs (they might be stored both locally AND on server)
  if (job.processing_method === 'streaming') {
    console.log('Deleting streaming job locally and from server');
    
    // Remove from local storage first
    jobs = jobs.filter(j => j.job_id !== jobId);
    saveStreamingJobsToStorage();
    updateJobsList();
    
    // Also try to delete from server (completed streaming jobs are saved to KV)
    // Don't await this - let it happen in background and don't fail if it errors
    fetch(API_BASE + '/delete-job', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ job_id: jobId })
    }).then(response => {
      if (response.ok) {
        webLogger.info('delete', 'Also deleted streaming job from server KV', { job_id: jobId });
      } else {
        // This is expected for local-only streaming jobs that haven't been saved to server
        webLogger.debug('Streaming job not found on server (local only)', { job_id: jobId });
      }
    }).catch(error => {
      webLogger.debug('Error deleting streaming job from server (likely local only)', { job_id: jobId, error: error.message });
    });
    
    console.log('Jobs after streaming deletion:', jobs.length, 'removed:', initialJobCount - jobs.length);
    webLogger.info('delete', 'Deleted streaming job locally', { job_id: jobId, count_before: initialJobCount, count_after: jobs.length });
    return;
  }
  
  // Handle server-stored jobs
  try {
    console.log('Deleting server job:', jobId);
    const response = await fetch(API_BASE + '/delete-job', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ job_id: jobId })
    });
    
    if (response.ok) {
      console.log('Server deletion successful, removing from local array');
      jobs = jobs.filter(j => j.job_id !== jobId);
      updateJobsList();
      
      console.log('Jobs after server deletion:', jobs.length, 'removed:', initialJobCount - jobs.length);
      webLogger.info('delete', 'Deleted server job', { job_id: jobId, count_before: initialJobCount, count_after: jobs.length });
    } else {
      const error = await response.json();
      console.error('Server deletion failed:', error);
      alert('Failed to delete job: ' + (error.error || 'Unknown error'));
    }
  } catch (error) {
    console.error('Delete error:', error);
    webLogger.error('Delete error', error);
    alert('Failed to delete job: ' + error.message);
  }
}

// viewTranscript function removed - now handled by toggleJobExpand inline

function formatTime(seconds) {
  if (!seconds || isNaN(seconds)) return '0:00';
  
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return mins + ':' + secs.toString().padStart(2, '0');
}

// Job expansion functionality
function toggleJobExpand(expandId, jobId) {
  const expandDiv = document.getElementById(expandId);
  const job = jobs.find(j => j.job_id === jobId);
  
  if (!job) return;
  
  if (expandDiv.classList.contains('max-h-0')) {
    // Expand
    expandDiv.classList.remove('max-h-0');
    expandDiv.style.maxHeight = 'none';
    
    // Show different content based on job status
    if (job.status === 'done') {
      // Show transcript view for completed jobs
      showInlineTranscript(job, expandDiv);
    } else {
      // Show job details for processing/failed jobs
      showJobDetails(job, expandDiv);
    }
  } else {
    // Collapse
    expandDiv.classList.add('max-h-0');
    expandDiv.style.maxHeight = '0';
    expandDiv.innerHTML = '';
  }
}

// Show transcript inline in the expanded area
async function showInlineTranscript(job, container) {
  console.log('=== showInlineTranscript called ===');
  console.log('Job object:', job);
  console.log('Job processing method:', job.processing_method);
  
  // Show loading state
  container.innerHTML = '<div class="p-4 text-center text-terminal-text-dim">Loading transcript...</div>';
  
  let transcript = null;
  
  // Handle streaming jobs differently since they're not stored on server
  if (job.processing_method === 'streaming') {
    console.log('Processing streaming job transcript');
    console.log('Available transcript fields:', {
      final_transcript: job.final_transcript,
      corrected_transcript: job.corrected_transcript,
      raw_transcript: job.raw_transcript,
      final_length: job.final_transcript?.length || 0,
      corrected_length: job.corrected_transcript?.length || 0,
      raw_length: job.raw_transcript?.length || 0
    });
    
    // Use the best available transcript
    const bestTranscript = job.corrected_transcript || job.final_transcript || job.raw_transcript;
    
    transcript = {
      final: bestTranscript || 'No transcript available',
      partials: bestTranscript ? [{
        text: bestTranscript,
        segments: []
      }] : []
    };
    console.log('Built streaming transcript object:', transcript);
    console.log('Selected transcript source:', {
      used: job.corrected_transcript ? 'corrected' : job.final_transcript ? 'final' : job.raw_transcript ? 'raw' : 'none',
      length: bestTranscript?.length || 0
    });
    
    webLogger.info('stream', 'Loading streaming job transcript', { 
      final_length: transcript.final?.length || 0,
      has_partials: transcript.partials?.length || 0 
    });
  } else {
    console.log('Fetching server transcript for job ID:', job.job_id);
    try {
      const response = await fetch(API_BASE + '/result?job_id=' + job.job_id);
      console.log('Server response status:', response.status);
      
      if (response.ok) {
        transcript = await response.json();
        console.log('Server transcript response:', transcript);
        console.log('Transcript structure check:', {
          has_final: !!transcript.final,
          final_length: transcript.final?.length || 0,
          has_partials: !!transcript.partials,
          partials_length: transcript.partials?.length || 0,
          partials_sample: transcript.partials?.[0]
        });
        
        webLogger.info('api', 'Loaded server transcript', { 
          final_length: transcript.final?.length || 0,
          partials_length: transcript.partials?.length || 0 
        });
      } else {
        console.error('Failed to fetch transcript, status:', response.status);
        const errorText = await response.text();
        console.error('Error response:', errorText);
        webLogger.error('Failed to fetch transcript', { status: response.status });
      }
    } catch (error) {
      console.error('Error fetching transcript:', error);
      webLogger.error('Failed to fetch transcript', error);
    }
  }
  
  console.log('Final transcript object before rendering:', transcript);
  console.log('Transcript validation:', {
    transcript_exists: !!transcript,
    has_final: !!(transcript?.final),
    final_not_empty: !!(transcript?.final && transcript.final !== 'No transcript available'),
    has_partials: !!(transcript?.partials),
    partials_length: transcript?.partials?.length || 0
  });
  
  if (!transcript || (!transcript.final && (!transcript.partials || transcript.partials.length === 0))) {
    console.log('No valid transcript found, showing error');
    container.innerHTML = '<div class="p-4 text-center text-status-error">Failed to load transcript</div>';
    return;
  }
  
  // Create the same side-by-side layout as before but inline
  let html = '<div class="border-t border-terminal-border bg-terminal-bg-light">';
  
  // Side-by-side layout: details on left, transcript on right
  html += '<div class="flex" style="height: 60vh;">';
  
  // Left side: Job details and action buttons (narrower for inline view)
  html += '<div class="w-64 flex-shrink-0 border-r border-terminal-border bg-gray-900/30 flex flex-col">';
  
  // Job details section
  html += '<div class="p-3 flex-1 overflow-y-auto">';
  html += '<div class="space-y-3">';
  
  // Basic job info
  html += '<div>';
  html += '<div class="text-terminal-accent font-bold mb-2 flex items-center gap-2 text-sm">';
  html += '<iconify-icon icon="mdi:information" class="text-xs"></iconify-icon> Job Info';
  html += '</div>';
  html += '<div class="space-y-1 text-xs text-terminal-text-dim">';
  html += '<div><strong>Status:</strong> ' + job.status + '</div>';
  html += '<div><strong>Size:</strong> ' + formatBytes(job.file_size || 0) + '</div>';
  html += '<div><strong>Method:</strong> ' + (job.processing_method || 'direct') + '</div>';
  if (job.total_segments > 0) {
    html += '<div><strong>Segments:</strong> ' + job.total_segments + '</div>';
  }
  html += '</div>';
  html += '</div>';
  
  // Processing settings
  html += '<div>';
  html += '<div class="text-terminal-accent font-bold mb-2 flex items-center gap-2 text-sm">';
  html += '<iconify-icon icon="mdi:cog" class="text-xs"></iconify-icon> Settings';
  html += '</div>';
  html += '<div class="space-y-1 text-xs text-terminal-text-dim">';
  html += '<div><strong>LLM:</strong> ' + (job.use_llm ? (job.llm_mode || 'enabled') : 'disabled') + '</div>';
  if (job.chunk_size_mb) {
    html += '<div><strong>Chunk:</strong> ' + job.chunk_size_mb + 'MB</div>';
  }
  html += '</div>';
  html += '</div>';
  
  // Transcript stats
  html += '<div>';
  html += '<div class="text-terminal-accent font-bold mb-2 flex items-center gap-2 text-sm">';
  html += '<iconify-icon icon="mdi:chart-line" class="text-xs"></iconify-icon> Stats';
  html += '</div>';
  html += '<div class="space-y-1 text-xs text-terminal-text-dim">';
  html += '<div><strong>Segments:</strong> ' + (transcript.partials?.length || 0) + '</div>';
  if (transcript.final) {
    html += '<div><strong>Length:</strong> ' + transcript.final.length + ' chars</div>';
  }
  html += '</div>';
  html += '</div>';
  
  html += '</div>'; // End details section
  html += '</div>'; // End scrollable details
  
  // Action buttons at bottom of left panel
  html += '<div class="p-3 border-t border-terminal-border space-y-2">';
  html += '<button onclick="window.copyTranscript(&quot;' + job.job_id.replace(/"/g, '&quot;') + '&quot;)" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-2 py-1 text-xs hover:bg-gray-700 transition-colors flex items-center gap-1 w-full">';
  html += '<iconify-icon icon="mdi:content-copy" class="text-xs"></iconify-icon> Copy Transcript';
  html += '</button>';
  html += '<button onclick="window.copyJobJson(&quot;' + job.job_id.replace(/"/g, '&quot;') + '&quot;)" class="bg-terminal-bg-light border border-terminal-border text-terminal-text px-2 py-1 text-xs hover:bg-gray-700 transition-colors flex items-center gap-1 w-full">';
  html += '<iconify-icon icon="mdi:code-json" class="text-xs"></iconify-icon> Copy JSON';
  html += '</button>';
  html += '</div>';
  
  html += '</div>'; // End left panel
  
  // Right side: Final transcript
  html += '<div class="flex-1 flex flex-col">';
  
  // Transcript header
  html += '<div class="p-2 border-b border-terminal-border bg-terminal-bg font-bold text-terminal-accent flex items-center gap-2 text-sm">';
  html += '<iconify-icon icon="mdi:text-box" class="text-sm"></iconify-icon> Final Transcript';
  html += '</div>';
  
  // Transcript content
  html += '<div class="flex-1 overflow-y-auto p-3 leading-relaxed text-terminal-text font-mono text-sm">';
  
  if (transcript.final && transcript.final !== 'No transcript available') {
    html += '<div class="whitespace-pre-wrap">' + transcript.final + '</div>';
  } else if (transcript.partials && transcript.partials.length > 0) {
    // Fallback to segmented transcript if no final transcript
    const segmentText = transcript.partials.map(partial => {
      if (partial.segments) {
        return partial.segments.map(segment => segment.text).join(' ');
      } else {
        return partial.text;
      }
    }).join(' ');
    if (segmentText.trim()) {
      html += '<div class="whitespace-pre-wrap">' + segmentText + '</div>';
    } else {
      html += '<div class="text-terminal-text-dim italic">No transcript content found</div>';
    }
  } else {
    html += '<div class="text-terminal-text-dim italic">No transcript available</div>';
  }
  
  html += '</div>'; // End transcript content
  html += '</div>'; // End right panel
  
  html += '</div>'; // End side-by-side layout
  html += '</div>'; // End container
  
  container.innerHTML = html;
}

// Show job details for non-completed jobs
function showJobDetails(job, container) {
  let html = '<div class="p-3 pt-0 border-t border-terminal-border bg-gray-900/30">';
  
  // Simplified job details in two columns
  html += '<div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">';
  html += '<div>';
  html += '<div class="text-terminal-accent font-bold mb-2"><iconify-icon icon="mdi:information" class="text-sm"></iconify-icon> Job Details</div>';
  html += '<div class="space-y-1 text-xs text-terminal-text-dim">';
  html += '<div>ID: ' + job.job_id + '</div>';
  html += '<div>Status: ' + job.status + '</div>';
  html += '<div>Upload: ' + (job.upload_method || 'direct') + '</div>';
  html += '<div>Processing: ' + (job.processing_method || 'direct') + '</div>';
  if (job.total_segments > 0) {
    html += '<div>Segments: ' + job.total_segments + '</div>';
  }
  html += '</div>';
  html += '</div>';
  
  html += '<div>';
  html += '<div class="text-terminal-accent font-bold mb-2"><iconify-icon icon="mdi:file-cog" class="text-sm"></iconify-icon> Processing Settings</div>';
  html += '<div class="space-y-1 text-xs text-terminal-text-dim">';
  html += '<div>LLM: ' + (job.use_llm ? (job.llm_mode || 'enabled') : 'disabled') + '</div>';
  if (job.chunk_size_mb) {
    html += '<div>Chunk Size: ' + job.chunk_size_mb + 'MB</div>';
  }
  html += '<div>File Size: ' + formatBytes(job.file_size || 0) + '</div>';
  html += '</div>';
  html += '</div>';
  html += '</div>';
  
  html += '</div>';
  
  container.innerHTML = html;
}

// Copy transcript functionality
async function copyTranscript(jobId) {
  console.log('copyTranscript called with jobId:', jobId);
  const job = jobs.find(j => j.job_id === jobId);
  console.log('Found job:', job);
  
  if (!job) {
    console.error('Job not found for ID:', jobId);
    return;
  }
  
  try {
    let transcriptText = '';
    
    // Handle streaming jobs differently since they're not stored on server
    if (job.processing_method === 'streaming') {
      console.log('Processing streaming job transcript');
      console.log('Job data:', {
        final_transcript: job.final_transcript,
        raw_transcript: job.raw_transcript,
        corrected_transcript: job.corrected_transcript
      });
      transcriptText = job.final_transcript || job.corrected_transcript || job.raw_transcript || 'No transcript available';
    } else {
      console.log('Fetching server transcript for job:', jobId);
      const response = await fetch(API_BASE + '/result?job_id=' + jobId);
      if (response.ok) {
        const data = await response.json();
        console.log('Server transcript response:', data);
        transcriptText = data.final || 'No transcript available';
      } else {
        console.error('Failed to fetch transcript, status:', response.status);
        transcriptText = 'Failed to fetch transcript';
      }
    }
    
    console.log('Final transcript text:', transcriptText);
    await navigator.clipboard.writeText(transcriptText);
    
    // Show feedback - find button by searching for the one that was clicked
    const buttons = document.querySelectorAll('button[onclick*="copyTranscript"]');
    let targetButton = null;
    for (const btn of buttons) {
      if (btn.getAttribute('onclick').includes(jobId)) {
        targetButton = btn;
        break;
      }
    }
    
    if (targetButton) {
      const originalText = targetButton.innerHTML;
      targetButton.innerHTML = '<iconify-icon icon="mdi:check"></iconify-icon> Copied!';
      targetButton.classList.add('bg-status-success');
      setTimeout(() => {
        targetButton.innerHTML = originalText;
        targetButton.classList.remove('bg-status-success');
      }, 2000);
    }
    
  } catch (error) {
    console.error('Failed to copy transcript:', error);
    webLogger.error('Failed to copy transcript', error);
    alert('Failed to copy transcript: ' + error.message);
  }
}

// Copy job JSON functionality
async function copyJobJson(jobId) {
  console.log('copyJobJson called with jobId:', jobId);
  const job = jobs.find(j => j.job_id === jobId);
  console.log('Found job for JSON copy:', job);
  
  if (!job) {
    console.error('Job not found for JSON copy, ID:', jobId);
    return;
  }
  
  try {
    let fullJobData = { ...job };
    
    // For non-streaming jobs, fetch full data from server
    if (job.processing_method !== 'streaming') {
      try {
        console.log('Fetching full transcript data for JSON export');
        const response = await fetch(API_BASE + '/result?job_id=' + jobId);
        if (response.ok) {
          const transcriptData = await response.json();
          console.log('Transcript data for JSON:', transcriptData);
          fullJobData.transcript_data = transcriptData;
        }
      } catch (error) {
        console.warn('Could not fetch full transcript data for JSON export', error);
        webLogger.warn('Could not fetch full transcript data for JSON export', error);
      }
    }
    
    const jsonText = JSON.stringify(fullJobData, null, 2);
    console.log('Generated JSON text length:', jsonText.length);
    await navigator.clipboard.writeText(jsonText);
    
    // Show feedback - find button by searching for the one that was clicked
    const buttons = document.querySelectorAll('button[onclick*="copyJobJson"]');
    let targetButton = null;
    for (const btn of buttons) {
      if (btn.getAttribute('onclick').includes(jobId)) {
        targetButton = btn;
        break;
      }
    }
    
    if (targetButton) {
      const originalText = targetButton.innerHTML;
      targetButton.innerHTML = '<iconify-icon icon="mdi:check"></iconify-icon> Copied!';
      targetButton.classList.add('bg-status-success');
      setTimeout(() => {
        targetButton.innerHTML = originalText;
        targetButton.classList.remove('bg-status-success');
      }, 2000);
    }
    
  } catch (error) {
    console.error('Failed to copy job JSON:', error);
    webLogger.error('Failed to copy job JSON', error);
    alert('Failed to copy job JSON: ' + error.message);
  }
}



// Make functions globally available for onclick handlers
window.deleteJob = deleteJob;
window.toggleJobExpand = toggleJobExpand;
window.copyTranscript = copyTranscript;
window.copyJobJson = copyJobJson;
window.refreshJobs = refreshJobs;

// Initialize when DOM is ready
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
} `
};
